# Notification Processing API Documentation

This document provides comprehensive documentation for the notification processing features in euicc-go.

**Last Updated:** 2025-11-01

---

## Table of Contents

- [Overview](#overview)
- [Quick Start](#quick-start)
- [API Reference](#api-reference)
- [Common Use Cases](#common-use-cases)
- [Error Handling](#error-handling)
- [Comparison with lpac](#comparison-with-lpac)

---

## Overview

The notification processing API provides high-level functions to automate the workflow of handling pending notifications on the eUICC. Notifications are generated by the eUICC when profile-related events occur (install, enable, disable, delete) and need to be sent to the SM-DP+ server.

### What are Notifications?

Notifications are event records stored on the eUICC that inform the SM-DP+ server about profile lifecycle events:

- **Install Notification**: Sent when a profile is successfully installed
- **Enable Notification**: Sent when a profile is enabled
- **Disable Notification**: Sent when a profile is disabled
- **Delete Notification**: Sent when a profile is deleted

### Why Process Notifications?

Notifications must be processed (sent to SM-DP+) to:
1. Inform the operator about profile status changes
2. Complete the profile lifecycle workflow
3. Maintain synchronization between eUICC and SM-DP+ server
4. Comply with GSMA SGP.22 specifications

---

## Quick Start

### Basic Usage - Process All Notifications

```go
package main

import (
    "context"
    "fmt"
    "log"

    "github.com/KilimcininKorOglu/euicc-go/lpa"
    "github.com/KilimcininKorOglu/euicc-go/driver/qmi"
)

func main() {
    // Initialize driver (example with QMI)
    driver, err := qmi.New("/dev/cdc-wdm0", 1)
    if err != nil {
        log.Fatal(err)
    }
    defer driver.Disconnect()

    // Create LPA client
    client, err := lpa.New(&lpa.Options{
        Channel: driver,
    })
    if err != nil {
        log.Fatal(err)
    }

    // Process all pending notifications with auto-removal
    results, err := client.ProcessAllNotifications(&lpa.ProcessNotificationsOptions{
        AutoRemove:      true,
        ContinueOnError: true,
    })
    if err != nil {
        log.Fatal(err)
    }

    // Display results
    for _, result := range results {
        if result.Success {
            fmt.Printf("✓ Processed notification %d\n", result.SequenceNumber)
            if result.Removed {
                fmt.Printf("  └─ Removed from eUICC\n")
            }
        } else {
            fmt.Printf("✗ Failed to process %d: %v\n", result.SequenceNumber, result.Error)
        }
    }
}
```

### Process Specific Notifications

```go
// Process specific notifications by sequence number
results, err := client.ProcessNotifications(
    &lpa.ProcessNotificationsOptions{
        AutoRemove:      true,
        ContinueOnError: true,
    },
    sgp22.SequenceNumber(1),
    sgp22.SequenceNumber(2),
    sgp22.SequenceNumber(3),
)
if err != nil {
    log.Fatal(err)
}
```

---

## API Reference

### Types

#### `NotificationProcessResult`

Contains the result of processing a single notification.

```go
type NotificationProcessResult struct {
    SequenceNumber sgp22.SequenceNumber  // Notification sequence number
    Success        bool                  // Whether processing succeeded
    Error          error                 // Error if processing failed
    Removed        bool                  // Whether notification was removed from eUICC
}
```

#### `ProcessNotificationsOptions`

Configuration options for notification processing.

```go
type ProcessNotificationsOptions struct {
    // AutoRemove automatically removes notifications from the eUICC after
    // successful processing (sending to SM-DP+).
    AutoRemove bool

    // ContinueOnError continues processing remaining notifications even if
    // one fails. Results for each notification are returned in the slice.
    ContinueOnError bool
}
```

### Functions

#### `ProcessNotifications`

```go
func (c *Client) ProcessNotifications(
    opts *ProcessNotificationsOptions,
    sequenceNumbers ...sgp22.SequenceNumber,
) ([]*NotificationProcessResult, error)
```

Processes notifications identified by their sequence numbers.

**Parameters:**
- `opts`: Configuration options (nil for defaults)
- `sequenceNumbers`: One or more sequence numbers to process

**Returns:**
- Slice of `NotificationProcessResult` for each processed notification
- Error if non-recoverable error occurs (when `ContinueOnError` is false)

**Workflow for each notification:**
1. Retrieve notification content via `ES10b.RetrieveNotificationsList`
2. Send notification to SM-DP+ server via `ES9p.HandleNotification`
3. Optionally remove from eUICC via `ES10b.RemoveNotificationFromList` (if `AutoRemove` is true)

**Example:**
```go
results, err := client.ProcessNotifications(
    &lpa.ProcessNotificationsOptions{
        AutoRemove: true,
        ContinueOnError: true,
    },
    sgp22.SequenceNumber(1),
    sgp22.SequenceNumber(2),
)
for _, result := range results {
    if result.Success {
        fmt.Printf("Processed notification %d\n", result.SequenceNumber)
    } else {
        fmt.Printf("Failed to process %d: %v\n", result.SequenceNumber, result.Error)
    }
}
```

#### `ProcessAllNotifications`

```go
func (c *Client) ProcessAllNotifications(
    opts *ProcessNotificationsOptions,
) ([]*NotificationProcessResult, error)
```

Retrieves and processes all pending notifications on the eUICC.

**Parameters:**
- `opts`: Configuration options (nil for defaults)

**Returns:**
- Slice of `NotificationProcessResult` for each processed notification
- Error if non-recoverable error occurs

**Equivalent to:**
```go
notifications, _ := client.ListNotification()
sequenceNumbers := extractSequenceNumbers(notifications)
results, err := client.ProcessNotifications(opts, sequenceNumbers...)
```

**Example:**
```go
results, err := client.ProcessAllNotifications(&lpa.ProcessNotificationsOptions{
    AutoRemove: true,
    ContinueOnError: true,
})
if err != nil {
    log.Fatal(err)
}
fmt.Printf("Processed %d notifications\n", len(results))
```

---

## Common Use Cases

### 1. Process All Notifications After Profile Installation

```go
// Download and install a profile
_, err := client.DownloadProfile(ctx, activationCode, nil)
if err != nil {
    log.Fatal(err)
}

// Process all pending notifications (including install notification)
results, err := client.ProcessAllNotifications(&lpa.ProcessNotificationsOptions{
    AutoRemove:      true,
    ContinueOnError: false, // Fail fast on errors
})
if err != nil {
    log.Fatal(err)
}

for _, result := range results {
    if result.Success {
        fmt.Printf("Sent notification %d to SM-DP+\n", result.SequenceNumber)
    }
}
```

### 2. Process Notifications with Custom Error Handling

```go
results, err := client.ProcessAllNotifications(&lpa.ProcessNotificationsOptions{
    AutoRemove:      true,
    ContinueOnError: true, // Continue even if some fail
})
if err != nil {
    log.Printf("Warning: Some notifications failed: %v\n", err)
}

// Analyze results
var successful, failed int
for _, result := range results {
    if result.Success {
        successful++
    } else {
        failed++
        log.Printf("Failed notification %d: %v\n", result.SequenceNumber, result.Error)
    }
}

fmt.Printf("Results: %d successful, %d failed\n", successful, failed)
```

### 3. Retry Failed Notifications

```go
func processWithRetry(client *lpa.Client, maxRetries int) error {
    for attempt := 1; attempt <= maxRetries; attempt++ {
        results, err := client.ProcessAllNotifications(&lpa.ProcessNotificationsOptions{
            AutoRemove:      true,
            ContinueOnError: true,
        })

        // Check if all succeeded
        allSuccess := true
        var failedSeqNums []sgp22.SequenceNumber

        for _, result := range results {
            if !result.Success {
                allSuccess = false
                failedSeqNums = append(failedSeqNums, result.SequenceNumber)
            }
        }

        if allSuccess {
            fmt.Printf("All notifications processed successfully\n")
            return nil
        }

        if attempt < maxRetries {
            fmt.Printf("Attempt %d: %d notifications failed, retrying...\n",
                attempt, len(failedSeqNums))
            time.Sleep(time.Second * 5)
        }
    }

    return fmt.Errorf("failed to process all notifications after %d attempts", maxRetries)
}
```

### 4. List Notifications Before Processing

```go
// First, list all pending notifications
notifications, err := client.ListNotification()
if err != nil {
    log.Fatal(err)
}

// Display notification details
fmt.Printf("Found %d pending notifications:\n", len(notifications))
for _, notif := range notifications {
    fmt.Printf("  - Seq %d: Event=%s, Address=%s\n",
        notif.SequenceNumber,
        notif.Event,
        notif.Address)
}

// Ask user for confirmation
fmt.Print("Process all notifications? (y/n): ")
var response string
fmt.Scanln(&response)

if response == "y" {
    results, err := client.ProcessAllNotifications(&lpa.ProcessNotificationsOptions{
        AutoRemove: true,
        ContinueOnError: true,
    })
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("Processed %d notifications\n", len(results))
}
```

### 5. Manual Notification Removal (Without Auto-Remove)

```go
// Process without auto-removal
results, err := client.ProcessAllNotifications(&lpa.ProcessNotificationsOptions{
    AutoRemove:      false, // Don't auto-remove
    ContinueOnError: true,
})
if err != nil {
    log.Fatal(err)
}

// Manually remove only successful notifications
for _, result := range results {
    if result.Success {
        err := client.RemoveNotificationFromList(result.SequenceNumber)
        if err != nil {
            log.Printf("Warning: Failed to remove notification %d: %v\n",
                result.SequenceNumber, err)
        }
    }
}
```

---

## Error Handling

### Common Errors

#### 1. Network Errors

```go
results, err := client.ProcessAllNotifications(&lpa.ProcessNotificationsOptions{
    AutoRemove:      true,
    ContinueOnError: true,
})

for _, result := range results {
    if !result.Success {
        // Check for network-related errors
        if strings.Contains(result.Error.Error(), "connection") ||
           strings.Contains(result.Error.Error(), "timeout") {
            fmt.Printf("Network error for notification %d: %v\n",
                result.SequenceNumber, result.Error)
        }
    }
}
```

#### 2. SM-DP+ Server Errors

```go
for _, result := range results {
    if !result.Success {
        // Check for server errors
        if strings.Contains(result.Error.Error(), "8.8.1") {
            fmt.Printf("SM-DP+ rejected notification %d\n", result.SequenceNumber)
        }
    }
}
```

#### 3. eUICC Errors

```go
results, err := client.ProcessAllNotifications(nil)
if err != nil {
    // Check for eUICC communication errors
    if strings.Contains(err.Error(), "retrieve notification") {
        log.Fatal("Failed to retrieve notifications from eUICC")
    }
}
```

### Best Practices

1. **Always use `ContinueOnError: true` for batch processing**
   ```go
   // Good: Continue processing even if some fail
   results, _ := client.ProcessAllNotifications(&lpa.ProcessNotificationsOptions{
       ContinueOnError: true,
   })
   ```

2. **Check individual results**
   ```go
   for _, result := range results {
       if !result.Success {
           log.Printf("Notification %d failed: %v\n",
               result.SequenceNumber, result.Error)
       }
   }
   ```

3. **Use `AutoRemove: true` for production**
   ```go
   // Good: Automatically clean up processed notifications
   results, _ := client.ProcessAllNotifications(&lpa.ProcessNotificationsOptions{
       AutoRemove: true,
   })
   ```

---

## Comparison with lpac

| Feature | lpac | euicc-go | Notes |
|---------|------|----------|-------|
| **Process All Notifications** | `lpac notification process -a` | `ProcessAllNotifications()` | Identical functionality |
| **Process Specific Notification** | `lpac notification process [seqnum]` | `ProcessNotifications(opts, seqnum)` | Identical functionality |
| **Auto-Remove Flag** | `-r` | `AutoRemove: true` | euicc-go uses options struct |
| **Continue on Error** | Default behavior | `ContinueOnError: true` | euicc-go provides explicit control |
| **Result Reporting** | JSON output | `NotificationProcessResult` slice | euicc-go provides programmatic access |
| **Error Details** | Exit code + message | Per-notification error in result | euicc-go provides granular error info |

### lpac vs euicc-go Examples

**lpac:**
```bash
# Process all notifications with auto-removal
lpac notification process -a -r

# Process specific notification
lpac notification process 1
```

**euicc-go:**
```go
// Process all notifications with auto-removal
results, err := client.ProcessAllNotifications(&lpa.ProcessNotificationsOptions{
    AutoRemove:      true,
    ContinueOnError: true,
})

// Process specific notification
results, err := client.ProcessNotifications(
    &lpa.ProcessNotificationsOptions{AutoRemove: true},
    sgp22.SequenceNumber(1),
)
```

---

## Performance Considerations

### Notification Processing Time

Processing a single notification involves:
1. **APDU communication** with eUICC (~100-200ms)
2. **HTTPS request** to SM-DP+ server (~200-500ms depending on network)
3. **Optional removal** from eUICC (~50-100ms)

**Total per notification:** ~350-800ms

### Batch Processing

```go
// Efficient: Process all in one call
results, _ := client.ProcessAllNotifications(&lpa.ProcessNotificationsOptions{
    AutoRemove:      true,
    ContinueOnError: true,
})

// Inefficient: Process one by one
notifications, _ := client.ListNotification()
for _, notif := range notifications {
    client.ProcessNotifications(nil, notif.SequenceNumber)
}
```

### Parallel Processing

The current implementation processes notifications **sequentially** to maintain order and avoid race conditions with the SM-DP+ server.

---

## Thread Safety

The `ProcessNotifications` and `ProcessAllNotifications` functions are **not thread-safe**. Do not call them concurrently from multiple goroutines on the same `lpa.Client` instance.

**Safe:**
```go
// Sequential processing
results1, _ := client.ProcessAllNotifications(opts)
results2, _ := client.ProcessAllNotifications(opts)
```

**Unsafe:**
```go
// Concurrent processing - DO NOT DO THIS
go client.ProcessAllNotifications(opts)
go client.ProcessAllNotifications(opts)
```

---

## See Also

- [SGP.22 v2.5 Specification](https://aka.pw/sgp22/v2.5) - Section 5.7.10 (Notification Management)
- [ES10b.RetrieveNotificationsList](https://aka.pw/sgp22/v2.5#page=192)
- [ES9p.HandleNotification](https://aka.pw/sgp22/v2.5#page=203)
- [lpac notification command](https://github.com/estkme-group/lpac)

---

## Changelog

### v1.3.0 (Current)
- ✅ Added `ProcessNotifications()` function
- ✅ Added `ProcessAllNotifications()` function
- ✅ Added `NotificationProcessResult` structure
- ✅ Added `ProcessNotificationsOptions` configuration
- ✅ Support for auto-removal of processed notifications
- ✅ Support for continue-on-error batch processing
